#pragma config(Sensor, port2,  leftLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port5,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port9,  middleBumpSensor, sensorVexIQ_Touch)
#pragma config(Sensor, port10, rightLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftDriveMotor, tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor4,          leftArmMotor,  tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          middleDriveMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          rightDriveMotor, tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor11,         rightArmMotor, tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#include ""

//#include "allign.c"

int threshold = 80;
int lineSpeed = 75;
int fourSpeed = 75;
int alingSpeed = 50;
int railHeading = 90;
int scoreHeading = 272;
int bumpHeading = 0;

task allign()
{
	int coords = (getGyroDegrees(gyroSensor));
	displayVariableValues(line1, coords);
	if(getGyroDegrees(gyroSensor) > coords)
	{
		setMotor(rightDriveMotor, alingSpeed);
		setMotor(leftDriveMotor, -alingSpeed);
		waitUntil(getGyroDegrees(gyroSensor) <= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}

	if(getGyroDegrees(gyroSensor) < coords)
	{
		setMotor(rightDriveMotor, -alingSpeed);
		setMotor(leftDriveMotor, alingSpeed);
		waitUntil(getGyroDegrees(gyroSensor) >= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}
}

task correctHeading()
{
	int coords = getGyroDegrees(gyroSensor);
	displaySensorValues(line1, gyroSensor);

  if (getGyroDegrees(gyroSensor) < coords)
	{
		setMotorSpeed(rightDriveMotor, fourSpeed-5);
		waitUntil(getGyroDegrees(gyroSensor) >= coords);
		//wait(1, seconds);
	}
	if (getGyroDegrees(gyroSensor) > coords)
	{
		setMotorSpeed(leftDriveMotor, fourSpeed-5);
		waitUntil(getGyroDegrees(gyroSensor) <= coords);
		//wait(1, seconds);
	}
	setMultipleMotors(fourSpeed, leftDriveMotor, rightDriveMotor);
}

void turnbot(const int coords, const int speed)
{
	if(getGyroDegrees(gyroSensor) > coords)
	{
		setMotor(rightDriveMotor, speed);
		setMotor(leftDriveMotor, -speed);
		waitUntil(getGyroDegrees(gyroSensor) <= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}

	if(getGyroDegrees(gyroSensor) < coords)
	{
		setMotor(rightDriveMotor, -speed);
		setMotor(leftDriveMotor, speed);
		waitUntil(getGyroDegrees(gyroSensor) >= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}
}

static void rightSensorTracking(const int count, const int speed, const int coords)
{
	int i=0;
  setMotorSpeed(middleDriveMotor, speed);
	while(i < count)
	{
		displaySensorValues(line4, gyroSensor);
		while(i < count-1)
		{
			displaySensorValues(line4, gyroSensor);
			if (getColorGrayscale(rightLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				waitUntil(getColorGrayscale(rightLightSensor) >= threshold);
			}
		}
		setMotorSpeed(middleDriveMotor, speed/2);
		waitUntil(getColorGrayscale(rightLightSensor) <= threshold);
		i++;
	}
	stopAllMotors();
	setMotor(middleDriveMotor, 0);
}

static void leftSensorTracking(const int count, const int speed, const int coords)
{
	int i=0;
  setMotorSpeed(middleDriveMotor, speed);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(leftLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				displaySensorValues(line4, gyroSensor);
				waitUntil(getColorGrayscale(leftLightSensor) >= threshold);
			}
		}
		setMotorSpeed(middleDriveMotor, speed/2);
		waitUntil(getColorGrayscale(leftLightSensor) <= threshold);
		i++;
	}
	stopAllMotors();
	setMotor(middleDriveMotor, 0);
}

static void middleDrive(const int ecount, const int speed)
	{
		moveMotorTarget(middleDriveMotor, ecount, speed);
		waitUntilMotorStop(middleDriveMotor);
	}

static void moveClaw(const int ecount, const int speed)
	{
		moveMotorTarget(leftArmMotor, ecount, speed);
		moveMotorTarget(rightArmMotor, ecount, speed);
		waitUntilMotorStop(leftArmMotor);
		setMultipleMotors(0, leftArmMotor, rightArmMotor);
	}

static void fourWheelDrive(const int ecount, const int coords, const int speed)
	{
	resetMotorEncoder(leftDriveMotor);
	setMotor(leftDriveMotor, speed);
	setMotor(rightDriveMotor, speed);

	repeatUntil(getMotorEncoder(leftDriveMotor) >= ecount)
  {
  	displayMotorValues(line2, leftDriveMotor);
  }
  stopAllMotors();

}

static void backup(const int ecount, const int speed)
	{
	moveMotorTarget(leftDriveMotor, ecount, speed);
	moveMotorTarget(rightDriveMotor, ecount, speed);
	waitUntilMotorStop(leftDriveMotor);
}

static void lift()
	{
		setMotorTarget(leftArmMotor, 250, 40);
		setMotorTarget(rightArmMotor, 250, 40);
		moveMotorTarget(leftDriveMotor, -100, 40);
		moveMotorTarget(rightDriveMotor, -100, 40);
		waitUntilMotorStop(leftArmMotor);
		stopAllMotors();
	}

void clawReset()
{
	int ecount=(0 -getMotorEncoder(leftArmMotor));
		moveMotorTarget(leftArmMotor, ecount, 35);
		moveMotorTarget(rightArmMotor, ecount, 35);
}

void bonusTray()
{
	middleDrive(-350, 50);
	moveClaw(250, 50);
	backup(3900, fourSpeed);
	backup(-325, fourSpeed);
	waitUntilMotorStop(leftDriveMotor);
	rightSensorTracking(2, lineSpeed, bumpHeading);
	middleDrive(55, 25);
	backup(400, fourSpeed);
	waitUntilMotorStop(leftDriveMotor);
	backup(-400, fourSpeed);
}

void setup()
{
		setMotorBrakeMode(middleDriveMotor, motorBrake);
		setMotorBrakeMode(leftArmMotor, motorBrake);
		setMotorBrakeMode(rightArmMotor, motorBrake);
		setMotorBrakeMode(leftDriveMotor, motorBrake);
		setMotorBrakeMode(rightDriveMotor, motorBrake);
		resetMotorEncoder(leftDriveMotor);
		resetMotorEncoder(rightDriveMotor);
		resetMotorEncoder(leftArmMotor);
		resetMotorEncoder(rightArmMotor);
		resetMotorEncoder(middleDriveMotor);
		resetGyro(gyroSensor);
}
task main()
{
		setup();
	  waitUntil(getBumperValue(middleBumpSensor) == 1);

// Blue Rings
		backup(100, fourSpeed); // ecount, speed
		turnbot(90, alingSpeed);
		moveClaw(-110, 75);
		startTask(allign);
		leftSensorTracking(7, lineSpeed, railHeading);  //Line Count, Speed, Coordinates
		stopTask(allign);
		//middleDrive(-25, 25);
		//backup(350, fourSpeed);
		//lift();
		//turnbot(scoreHeading, alingSpeed);
		//leftSensorTracking(1, lineSpeed, scoreHeading);
		//moveClaw(300, 75);
		//startTask(correctHeading);
		//fourWheelDrive(750, scoreHeading, fourSpeed);
		//stopTask(correctHeading);
		//backup(225, fourSpeed);
		//middleDrive(-25, 25);
		//moveClaw(-400, 75);
		//backup(-935, fourSpeed);
		//clawReset();
		//waitUntil(getBumperValue(middleBumpSensor) == 1);

// Green Rings
		resetMotorEncoder(leftDriveMotor);
		resetMotorEncoder(rightDriveMotor);
		resetGyro(gyroSensor);
		backup(100, fourSpeed); // ecount, speed
		turnbot(80, alingSpeed);
		moveClaw(-110, 75);
		leftSensorTracking(5, lineSpeed, railHeading);  //Line Count, Speed, Coordinates
		middleDrive(-25, 25);
		backup(350, fourSpeed);
		lift();
		turnbot(scoreHeading, alingSpeed);
		leftSensorTracking(1, lineSpeed, scoreHeading);
		moveClaw(300, 75);
		fourWheelDrive(750, scoreHeading, fourSpeed);
		backup(225, fourSpeed);
		middleDrive(-25, 25);
		moveClaw(-400, 75);
		backup(-935, fourSpeed);
		clawReset();
		waitUntil(getBumperValue(middleBumpSensor) == 1);


		//BONUS TRAY
		resetMotorEncoder(leftDriveMotor);
		resetMotorEncoder(rightDriveMotor);
		resetGyro(gyroSensor);
		bonusTray();
	}
