#pragma config(Sensor, port2,  leftLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port5,  gyroSensor,     sensorVexIQ_Gyro)
#pragma config(Sensor, port8,  middleLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Sensor, port9,  middleBumpSensor, sensorVexIQ_Touch)
#pragma config(Sensor, port10, rightLightSensor, sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftDriveMotor, tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor4,          leftArmMotor,  tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          middleDriveMotor, tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor7,          rightDriveMotor, tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor11,         rightArmMotor, tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int threshold = 50;

void allign(const int coords, const int speed)
{
	if(getGyroHeading(gyroSensor) > coords)
	{
		setMotor(rightDriveMotor, speed);
		setMotor(leftDriveMotor, -speed);
		waitUntil(getGyroHeading(gyroSensor) <= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}

	if(getGyroHeading(gyroSensor) < coords)
	{
		setMotor(rightDriveMotor, -speed);
		setMotor(leftDriveMotor, speed);
		waitUntil(getGyroHeading(gyroSensor) >= coords);
		setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}
}

static void rightSensorTracking(const int count, const int speed, const int coords)
{
	int i=0;
  setMotorSpeed(middleDriveMotor, speed);
	while(i < count)
	{
		while(i < count-1)
		{
			if (getColorGrayscale(rightLightSensor) <= threshold)
			{
				i++;
				displayVariableValues(line2, i);
				waitUntil(getColorGrayscale(rightLightSensor) >= threshold);
				allign(coords, 10);
			}
		}
		setMotorSpeed(middleDriveMotor, speed/2);
		waitUntil(getColorGrayscale(rightLightSensor) <= threshold);
		i++;
	}
	stopAllMotors();
	setMotor(middleDriveMotor, 0);
}

static void middleDrive(const int ecount, const int speed)
	{
		moveMotorTarget(middleDriveMotor, ecount, speed);
		waitUntilMotorStop(middleDriveMotor);
	}

static void moveClaw(const int ecount, const int speed)
	{
		moveMotorTarget(leftArmMotor, ecount, speed);
		moveMotorTarget(rightArmMotor, ecount, speed);
		waitUntilMotorStop(leftArmMotor);
	}

static void fourWheelDrive(const int ecount, const int speed)
	{
		moveMotorTarget(leftDriveMotor, ecount, speed);
		moveMotorTarget(rightDriveMotor, ecount, speed);
		waitUntilMotorStop(leftDriveMotor);
	}

static void lineDrive(const int ecount, const int speed)
	{
		//moveMotorTarget(leftDriveMotor, ecount, speed);
		//moveMotorTarget(rightDriveMotor, ecount, speed);
		lineTrackLeft(leftLightSensor, threshold, speed, speed-5);
		waitUntil(getMotorEncoder(leftDriveMotor) >= ecount);
	}

static void leftTurnL(const int deg, const int speed)
	{
			setMotor(leftDriveMotor, speed);
			setMotor(rightDriveMotor, -speed);
			waitUntil(getGyroHeading(gyroSensor) >= deg);
			setMultipleMotors(0, rightDriveMotor, leftDriveMotor);
	}
static void lift()
	{
		setMotorTarget(leftArmMotor, 250, 40);
		setMotorTarget(rightArmMotor, 250, 40);
		moveMotorTarget(leftDriveMotor, -100, 40);
		moveMotorTarget(rightDriveMotor, -100, 40);
		waitUntilMotorStop(leftArmMotor);
		stopAllMotors();
	}

task main()
{
	resetMotorEncoder(leftDriveMotor);
	resetMotorEncoder(rightDriveMotor);
	resetMotorEncoder(middleDriveMotor);
	resetGyro(gyroSensor);
	middleDrive(-350, 50);
	moveClaw(250, 50);
	fourWheelDrive(4170, 100);
	fourWheelDrive(-425, 100);
	rightSensorTracking(2, 50, 0);
	middleDrive(50, 25);
	fourWheelDrive(500, 75);
	fourWheelDrive(-500, 75);
}
